<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <title>SS24 - start right (tm)</title>
    <script src="./js/d3.min.js"></script>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-polylinedecorator/dist/leaflet.polylineDecorator.js"></script>
    <script src="https://unpkg.com/leaflet-fullscreen/dist/Leaflet.fullscreen.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-fullscreen/dist/leaflet.fullscreen.css" />
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database-compat.js"></script>
    <script src="./data.js"></script>
    <script src="./function.js"></script>
    <script src="./js/d3.min.js"></script>


  </head>
  <style>
    
  table, th, td{border:2px solid white;border-collapse: collapse;padding-left: 5px;padding-right: 5px;text-align: center;
    
    font-size: 3vh}   
    td { font-size: 2vh }
      body {font-family: Arial}

      #map {     height: 600px;
        width: 100%;}
      .leaflet-control-attribution {
            color: #313131 !important;
            background: rgba(0, 0, 0, 0.6);
            font-size: 12px;
            padding: 3px 5px;
        }

        .leaflet-control-attribution a {
            color: #000000 !important;
            text-decoration: none;
        }

        .leaflet-control-attribution a:hover {
            color: #000000 !important;
        }
  </style>
  <body style="overflow: hidden;background-color: black;color:white">


    <div id="map_div" style="width:100%;height: 100%"></div>

  <br>
  <!--  <img src=".//safe_events_logo-1.png" style="width: 30%" id ="evtlog" onclick="d3.select('#evtlog').remove()" >
  -->
 




  <!--
  <input id ="imgstr1" type="number" style ="font-size: 24px" step=0.0001 onchange="imageBounds[0][0]=this.value;imageOverlay.setBounds(imageBounds);">
  <input id ="imgstr2" type="number" step=0.0001 onchange="imageBounds[0][1]=this.value;imageOverlay.setBounds(imageBounds);">
  <input id ="imgstr3" type="number" step=0.0001 onchange="imageBounds[1][0]=this.value;imageOverlay.setBounds(imageBounds);">
  <input id ="imgstr4" type="number" step=0.0001 onchange="imageBounds[1][1]=this.value;imageOverlay.setBounds(imageBounds); ">
  -->

  </body>
  <script>
    setview9 = {grid:[24.99646971811259, 46.5075],zoom:17.5}
    logotoggle = true
    
   /*  Diese 4 Zeilen sind fÃ¼r den Fall, dass man das Bild im Hintergrund nochmal zerren muss, dazu sind die number.inputs aus einzukommentieren
  d3.select('#imgstr1').attr("value",imageBounds[0][0])
  d3.select('#imgstr2').attr("value",imageBounds[0][1])
  d3.select('#imgstr3').attr("value",imageBounds[1][0])
  d3.select('#imgstr4').attr("value",imageBounds[1][1])
  */

  initialise_map()
  initialise_settings()
  initialise_firebase()
  database = firebase.database();
  ref = database.ref('/soundstorm/SS24aux/day'+heutag+'/camcounts/');
  ref.on('value', (snapshot) => {
  count_data = snapshot.val()
  count_datain = make_graphdata({usage:count_data.IN,zeit:count_data.zeit})
  count_dataout = make_graphdata({usage:count_data.OUT,zeit:count_data.zeit})
  })


  read_current()
  daydata = read_a_day(24,heutag)

  setTimeout(function(){total_people},3000)
  /*
  setInterval(function (){refresh()},180000)
  ref.on('value', (snapshot) => {
  current = snapshot.val()
  for(i=0;i<stages_list.length;i++){
  if(current[stages_list[i].name] != undefined){
  */
  function jetzt_plot_malen(welcher_plot){



  drecks_now = settim.getTime()
  settim_slot =0
  for (i=0;i<graphdata["Big Beast Left"].zeit.length-1;i++){


  if (drecks_now> graphdata["Big Beast Left"].zeit[i].getTime()
  && drecks_now< graphdata["Big Beast Left"].zeit[i+1].getTime())
    settim_slot = i
  }


  data=[]



  if(welcher_plot=="general"){


  progres = estimateProgression({usage:addArrays(count_data.IN,count_data.OUT),zeit:count_data.zeit},1)

  progres2 = estimateProgression({usage:addArrays(count_data.IN,count_data.OUT),zeit:count_data.zeit},2)
  progres3 = estimateProgression({usage:addArrays(count_data.IN,count_data.OUT),zeit:count_data.zeit},3)



  data.push(
  {
  x:  total_people.zeit, //neu graph_data[selected_area.id].data_time,
  y:  total_people.usage, //neu graph_data[selected_area.id].data,

  yaxis:"y1",
  mode: 'lines',   fill: 'tozeroy',

  name: "count on site",
  line: {shape: 'spline',color: "steelblue"},
  type: 'scatter'  
  })
  data.push(
  {
  x:  graphdata["Big Beast Left"].zeit, //neu graph_data[selected_area.id].data_time,
  y:  referens_daten.usage, //neu graph_data[selected_area.id].data,

  yaxis:"y1",


  mode: 'lines',
  name: "Day 2 - 2023",
  line: {shape: 'spline',color:"black",dash: 'dashdot'},
  type: 'scatter'    })
  crsum_arr =addArrays(count_data.IN,count_data.OUT)
  data.push(
  { x: count_data.zeit,
  y: crsum_arr,
  mode: 'lines',

  name: "crowd count total",
  line: {shape: 'spline',color:"green"},
  type: 'scatter'    }
  )
  // hier die steigungen eingeben

  hund = settim.getTime()
  hund += (60*60*1000*2)
  hund = new Date(hund)
  hund2 = settim.getTime()
  hund2 -= (60*60*1000)
  hund2 = new Date(hund2)

  //hund3 = count_data.zeit[]
  //hund4 = count_data.zeit
  gr_layout.shapes.push(  {
            type: 'line',
            x0:  progres.zeit[0],/////hund2,
            y0: progres.usage[0],//total_people.usage[settim_slot-4],
            x1: progres.zeit[1],
            y1: progres.usage[1],
            name: "progression",
            line: {
            color: "green",
            dash: 'dashdot',
            width: 1.5
            }} )
            gr_layout.shapes.push(  {
            type: 'line',
            x0:  progres2.zeit[0],/////hund2,
            y0: progres2.usage[0],//total_people.usage[settim_slot-4],
            x1: progres2.zeit[1],
            y1: progres2.usage[1],
            name: "progression",
            line: {
            color: "green",
            dash: 'dashdot',
            width: 1.5
            }} )
            gr_layout.shapes.push(  {
            type: 'line',
            x0:  progres3.zeit[0],/////hund2,
            y0: progres3.usage[0],//total_people.usage[settim_slot-4],
            x1: progres3.zeit[1],
            y1: progres3.usage[1],
            name: "progression",
            line: {
            color: "green",
            dash: 'dashdot',
            width: 1.5
            }} )

  gr_layout.shapes.push(  {
            type: 'line',
            x0: hund2,
            y0: crsum_arr[settim_slot-4],
            x1: hund,
            y1: crsum_arr[settim_slot]+3*(crsum_arr[settim_slot]),//*ruckschau,
            name: "progression2",
            line: {
            color: "green",
            dash: 'dashdot',
            width: 1
            }} )
  }
  if(welcher_plot=="camcounts"){



  data.push(
  { x: count_data.zeit,
  y: addArrays(count_data.IN,count_data.OUT),
  mode: 'lines',

  name: "crowd count total",
  line: {shape: 'spline',color:"green"},
  type: 'scatter'    }
  )

  data.push({
  x:  count_datain.zeit, //neu graph_data[selected_area.id].data_time,
  y:   addArrays(count_data.IN,count_data.OUT), //neu graph_data[selected_area.id].data,

  yaxis:"y1",
  mode: 'lines',
  //   fill: 'tonexty',
  name: "SUM",
  line: {shape: 'spline'},
  type: 'scatter' 


  },
  {
  x:  count_datain.zeit, //neu graph_data[selected_area.id].data_time,
  y:  count_datain.usage, //neu graph_data[selected_area.id].data,

  yaxis:"y1",
  mode: 'lines',
  //   fill: 'tonexty',
  name: "IN",
  line: {shape: 'spline'},
  type: 'scatter'  
  },   {
  x:  count_dataout.zeit, //neu graph_data[selected_area.id].data_time,
  y:  count_dataout.usage, //neu graph_data[selected_area.id].data,

  yaxis:"y1",
  mode: 'lines',
  // fill: 'tonexty',
  name: "OUT",
  line: {shape: 'spline'},
  type: 'scatter'  
  })
  }


          








  }
  function initialise_settings(){
  ruckschau = 2
  show_event = false
  show_tensdens = false
  show_progress23 = false
  show_progress = false
  show_cap=false
  //startfest = new Date ("2022-11-26T12:00")
  //endfest = new Date ("2022-11-29T12:00")
  timer = false
  zoomflip = true
  ylimit =7000
  liniendicke = 5
  hinterfarbe = true
  xlimit = 72
  tagausw =0
  settim_slot =0
  layout = 1//0.6
  lio =  d3.select('#lio_div').style('width',fenster.breite*0.5+"px").style('height',fenster.hoehe*0.53+"px")
  reo =  d3.select('#reo_div').style('width',fenster.breite*0.5+"px").style('height',fenster.hoehe*0.53+"px").style('overflow',"hidden")
  liu =  d3.select('#liu_div').style('width',fenster.breite*layout+"px").style('height',fenster.hoehe*0.5+"px")
  // reu =  d3.select('#reu_div').style('width',fenster.breite*(1-layout)+"px").style('height',fenster.hoehe*0.45+"px")

  reo.append('br')
  tidi = reo.append('span').style('margin','auto').text('DAY 1 - Time 10:15').style("font-size", "5vh").style("font-weight",700)

  .on('click',function (){logotoggle = !logotoggle; writedisp9ToFirebase()}).style('cursor', 'pointer')

  reo.append('br')
  reo.append('br')
  reo.append('br')
  reo.append('br')
  tabero = reo.append('table').style('width',"100%").style('margin','auto').style('width','95%').style('margin-top',"5px")//.style("font-size", "5px")
  temp = tabero.append('tr').style('background-color',"grey")
  //temp.append("th").text("no.")
  temp.append("th").text("stage").style('width',"30%")
  temp.append("th").text("usage").style('width',"17%")

  temp.append("th").text("density").style('width',"17%")
  temp.append("th").text("tension").style('width',"17%")

  tuc =[]
  ttc = [      ]
  tpc =[]

  tdc=[]
  butarr=[]


  // tabelle malen

  for (i=0;i<stages_list.length;i++){let j =i
  temp = tabero.append('tr')
  // temp.append('td').text(i)

  if(stages_list[i].name == "Green Space 4"){
  nurwegenneon ="Neon"
  }else{nurwegenneon = stages_list[i].name}

  butarr.push( temp.append('td').text(nurwegenneon)
  .style("cursor", "pointer").style("font-weight",700) 
        .on('click',  function(){ select_area(j)})  )

  tuc.push(temp.append("td").text("u"+i).style("font-weight",700).style("color","black"))

  tdc.push(temp.append("td").text("d"+i).style("font-weight",700).style("color","black"))
  ttc.push(temp.append("td").text("t"+i).style("font-weight",700).style("color","black"))
  //tpc.push(temp.append("td").text("p"+i).style("font-weight",700))
  }
  //tpc[5].style('color',"white")
  //tpc[13].style('color',"white")
  //tpc[14].style('color',"white")
  //tpc[12].style('color',"white")
  /*    
  tuc[14].style('color',"white")
  tuc[14].style('color',"white")
  ttc[14].style('color',"white")
  tpc[14].style('color',"white")
  */

  reo.append('br')
  //tabero2 = reo.append('table').style('width',"100%").style('margin','auto').style('width','95%')//.style('margin-top',"5px")

  

  /*slider =  d3.select('#katze').append('input').attr('type','range').style('width',"96%").style('height',"3%").style('margin','auto').style('display', 'block')
  .attr('max',44).attr('min',0).attr('step',1).on('change',

    function(){
    settim = new Date("2024-12-08T17:00")
    settim= settim.getTime() + this.value*60*1000*15 
    //settim = Math.round(settim/(1000*15*60))*1000*15*60
    currentTimestamp = settim
    settim_slot = this.value-2
    settim = new Date(settim)


        refresh();})
*/

  but_div = d3.select('body').append('div')//.style("position", "absolute").style("bottom", "35px")
  but_div.append('br')
  

  but_div.append('br')


  }
  function refresh(){
settim = new Date()
  //hier gehts weiter
    for(i=0;i<stages_list.length;i++){
                  if(graphdata[stages_list[i].name] != undefined){
                    temp = graphdata[stages_list[i].name]
                    let  fcol = farbskala[Math.round(temp.usage[settim_slot]/10)]
                    let col = farbskala[Math.min(10,Math.round(temp.density[settim_slot])*2)]
                  if(Math.min(10,Math.round(temp.density[settim_slot])*2) > 0  )
                  {  stages_list[i].geo.setStyle({
                    //   opacity:1,
                        fillOpacity:0.6,
                        fillColor: fcol,
                        color: col,
                        "weight": 3
                  })}
                  }
  }



  temp = settim.getTime()
  for ( i=0 ;i<graphdata["Big Beast Left"].zeit.length-1;i++){
  if(temp >= graphdata["Big Beast Left"].zeit[i] &&temp < graphdata["Big Beast Left"].zeit[i+1]){
  settim_slot = i
  }
  }

  drecks=""
  if(settim.getMinutes()<10){drecks = "0"}
  tidi.text('DAY '+heutag+' - Time ' +settim.getHours() +":"+drecks+settim.getMinutes())

  q=0
  Object.keys(graphdata).forEach((key) => {
  tempart = current[stages_list[q].name]
  //let  fcol = 
  /*
  mÃ¶glichkeit neue objekte einzufÃ¼gen und ereignisse 
  eine ansicht fÃ¼r den nutzer die anders ist als die des desks
  vlt bekommen die spotter auch die mÃ¶glichkeit einen grpahen oder zahlen zu sehene. wann ist peakt zb

  mit fingerdruck einen hotspot einzaichnen oder eine zone mit hoher density
  eine person die die aufgabe hat per kamera daten zu sammeln , vlt bekommt der desk die mÃ¶glichkeit fragzeichen 

  geplante bzw erwartete bewegungen sollten eingetragenw erden kÃ¶nnen

  push und pull Ã¼ber bekannte achsen wÃ¤re geeignet um per bewegungen vorher zu sehen
  vlt einzelne dots die 100 personen reprÃ¤sentieren die Ã¼ber den platz wandern

  feuerwerk einzeichnen
  timeline befÃ¼llen

  isometrische ansicht

  keine frabigen pfeil, oder zumindest kein langes draufbleiben sondern mehrere werden vom system automatisch zusammengefasst




  */



  if (Math.round(graphdata[key].usage[settim_slot]) == NaN)[alert(graphdata[key].usage[settim_slot])]
  pfeil =" â"
  if(graphdata[key].usage[settim_slot]>graphdata[key].usage[settim_slot-1]){pfeil = " â²"}
  if((graphdata[key].usage[settim_slot])<graphdata[key].usage[settim_slot-1]){pfeil =" â¼" }

  tuc[q].text(Math.round(graphdata[key].usage[settim_slot])+ " %" +pfeil) //*(stages_list[q].capacity/100)))
  tuc[q].style('background-color',farbskala[Math.round(graphdata[key].usage[settim_slot]/10)]

  //farbskala[(10,Math.round(graphdata[key].usage[settim_slot]/10))]
  )
  if(isNaN(graphdata[key].usage[settim_slot])){tuc[q].text("")}
  // ficko
  pfeil =" â"
  if(graphdata[key].density[settim_slot]>graphdata[key].density[settim_slot-1]){pfeil =" â²"}
  if(graphdata[key].density[settim_slot]<graphdata[key].density[settim_slot-1]){pfeil = " â¼" }
  tdc[q].text(Math.round(graphdata[key].density[settim_slot]) +pfeil)
  tdc[q].style('background-color',farbskala[Math.min(10,Math.round(graphdata[key].density[settim_slot])*2)]
  //farbskala[Math.min(10,Math.round(graphdata[key].density[settim_slot]*2))]
  )
  if(isNaN(graphdata[key].density[settim_slot])){tdc[q].text("")}
  pfeil =" â"
  if(graphdata[key].tension[settim_slot]>graphdata[key].tension[settim_slot-1]){pfeil =" â²" }
  if(graphdata[key].tension[settim_slot]<graphdata[key].tension[settim_slot-1]){pfeil =" â¼" }
  ttc[q].text(Math.round(graphdata[key].tension[settim_slot]) +pfeil)
  ttc[q].style('background-color',farbskala[Math.round(graphdata[key].tension[settim_slot])])

  //tpc[q].text(Math.round((graphdata[key].usage[settim_slot]*stages_list[q].capacity)/100).toLocaleString('en-US'))
  //if(isNaN(graphdata[key].usage[settim_slot]*stages_list[q].capacity)/100){tpc[q].text("")}

  if(isNaN(graphdata[key].tension[settim_slot])){ttc[q].text("")}
  // tpc[q].style('background-color',farbskala[Math.round(graphdata[key].usage[settim_slot]/15)])
  q++
  })

  /*


  // tabelle 2 akkuallisieren
  scan_c = (interpolate_general(ticket_data.tot,ticket_data.time))
  scan_rate = ticket_data.tot[(ticket_data.tot.length-1)]-ticket_data.tot[ticket_data.tot.length-2]

  l3 = new  Date (ticket_data.time[(ticket_data.tot.length-1)])
  l4 = new Date (ticket_data.time[(ticket_data.tot.length-2)])
  l3 = l3.getTime()
  l4 = l4.getTime()
  l5 = (l3-l4)/(60*60*1000)            
  scan_rate = scan_rate / l5          

  l1= (interpolate_general(cr_count.in_tot,cr_count.time))
  l2 = (interpolate_general(cr_count.out_tot,cr_count.time))
  onsite_cur = scan_c- graph_data[12].data[settim_slot]

  field_sca.text(scan_c.toLocaleString('en-US'))
  field_inc.text(l1.toLocaleString('en-US'))
  field_outc.text(l2.toLocaleString('en-US'))

  field_difc.text((l1-l2).toLocaleString('en-US'))
  //field_rate.text(scan_rate.toLocaleString('en-US'))


  onsite_cur2 = Math.ceil((onsite_cur/100000)*100/20)

  //  onsite.setStyle({fillColor: farbskala[onsite_cur2]})
  field_site.text(onsite_cur.toLocaleString('en-US')).style('background-color',farbskala[onsite_cur2])
  // Zeitanzeige aktualisieren
  ttt = "x"
  if (settim.getDate()==26){ttt = 1}
  if (settim.getDate()==27){ttt = 2}
  if (settim.getDate()==28){ttt = 3}
  if (settim.getDate()==29){ttt = 4}
  rr1=""
  rr2 =""
  if (settim.getHours()<10){rr1="0"}
  if (settim.getMinutes()<10){rr2="0"}



  aa = settim.getTime()




  //rechnen()
  data=[]

  data.push(
  {
  x:  graphdata[selected_area.name].zeit, //neu graph_data[selected_area.id].data_time,
  y:  graphdata[selected_area.name].usage, //neu graph_data[selected_area.id].data,
  yaxis:"y1",
  mode: 'lines',
  fill: 'tonexty',
  name: selected_area.name,
  line: {shape: 'spline'},
  type: 'scatter'  
  })
  initialise_chart(data)*/
  // update_map();
  // update_table()

  data=[]
  /*
  tempa = new Date()
  tempa = tempa.getTime()
  tempb = tempa +(60*60*1000)
  temper = addArrays(count_data.IN,count_data.OUT)
  steigung = (temper [settim_slot]-temper[settim_slot-1])      

  //(graph_data[selected_area.name].data[settim_slot-ruckschau]-graph_data[selected_area].data[settim_slot])/ruckschau
  gr_layout.shapes.push(  {
  type: 'line',
  x0: settim,
  y0: temper[settim_slot],
  x1: temp,
  y1: temper[settim_slot]-(steigung*4),//*ruckschau,
  line: {
  color: "black",
  dash: 'dashdot',
  width: 1
  }} )

  */
  data.push(
  { x: count_data.zeit,
  y: addArrays(count_data.IN,count_data.OUT),
  mode: 'lines',

  name: "crowd count total",
  line: {shape: 'spline',color:"green"},
  type: 'scatter'    }
  )
  data.push(



  {
  x:  total_people.zeit, //neu graph_data[selected_area.id].data_time,
  y:  total_people.usage, //neu graph_data[selected_area.id].data,

  yaxis:"y1",
  mode: 'lines',   fill: 'tozeroy',

  name: "count on site",
  line: {shape: 'spline',color: "steelblue"},
  type: 'scatter'  
  })
  /*
  data.push(
  {
  x:  graphdata["Big Beast Left"].zeit, //neu graph_data[selected_area.id].data_time,
  y:  referens_daten.usage, //neu graph_data[selected_area.id].data,

  yaxis:"y1",


  mode: 'lines',
  name: "Reference Data",
  line: {shape: 'spline',color:"black",dash: 'dashdot'},
  type: 'scatter'    })
  */
   
  }
  function nowbutton(){

  settim = new Date()

  refresh()

  }
  //// diese Funktion ist unter gleichem namen aber mit anderen funktionen in der report ansicht
  function select_area(set_area){
  ;selected_area.name=stages_list[set_area].name;
  selected_area.id=set_area

  data=[]
  data.push(
  {
  x:  graphdata[selected_area.name].zeit, //neu graph_data[selected_area.id].data_time,
  y:  graphdata[selected_area.name].usage, //neu graph_data[selected_area.id].data,
  yaxis:"y1",
  mode: 'lines',
  fill: 'tonexty',
  name: selected_area.name,
  line: {shape: 'spline'},
  type: 'scatter'  
  })

  //Plotly.update('liu_div', data)  
  initialise_chart(data)      
  //dens_slider.node().dispatchEvent(new Event('input'));

  }
  function interpolate(u){

  temp=0
  aa = settim.getTime()
  for(i=0;i<graph_data[u].data.length;i++){

  bbb = new Date(graph_data[u].data_time[i])
  ccc = new Date(graph_data[u].data_time[i+1])


  bb = bbb.getTime()
  cc = ccc.getTime()

  //if(aa<bb||aa>cc){temp=0}
  if (aa==bb){temp = graph_data[u].data[i]; }
  if (aa==cc){temp = graph_data[u].data[i+1]; }
  if(aa>bb && aa<cc){

  temp = ((aa-bb)/(cc-bb))*((graph_data[u].data[i+1]-graph_data[u].data[i]))+graph_data[u].data[i]

  }}



  return Math.round(temp)}
  function interpolate_dens(u){

  //temp=0
  aa2 = settim.getTime()

  for(i=0;i<graph_data[u].dens.length-1;i++){  //

  let bbb2 = new Date(graph_data[u].time[i])
  let ccc2 = new Date(graph_data[u].time[i+1])

  let bb2 = bbb2.getTime()
  let cc2 = ccc2.getTime()


  if (aa2<bb2){temper = 0 }
  if (aa2==bb2){temper = graph_data[u].dens[i]; }
  if (aa2==cc2){temper = graph_data[u].dens[i+1]; }

  if(aa2>bb2 && aa2<cc2){   temper = ((aa2-bb2)/(cc2-bb2))*((graph_data[u].dens[i+1]-graph_data[u].dens[i]))+graph_data[u].dens[i]
  }}      


  return Math.round(temper)}
  function interpolate_general(set,timeset){


  searchtime = settim.getTime()

  for(i=0;i<set.length-1;i++){


  tim_interv_left = new Date(timeset[i])
  tim_interv_right = new Date(timeset[i+1])

  tim_interv_left = tim_interv_left.getTime()
  tim_interv_right = tim_interv_right.getTime()


  found=0
  if (searchtime==tim_interv_left){found = set[i];break }
  if (searchtime==tim_interv_right){found = set[i+1];break }
  if(searchtime>tim_interv_left && searchtime<tim_interv_right){

  found = ((searchtime-tim_interv_left)/(tim_interv_right-tim_interv_left))*((set[i+1]-set[i]))+set[i]
  ;break
  }}

  return Math.round(found)}
  d3.select('#map_div').style('width',fenster.breite+"px").style('height',fenster.hoehe+"px")
  d3.select('#liu_div').style('width',"0px").style('height',"0px")
  d3.select('#reo_div').style('width',"0px").style('height',"0px")
 
 
 
 
 
 
 
 
 
  set_name = "demo"

  
infotag =d3.select('body').append('p')
setInterval(() => {refresh()
  
}, 5000);
  </script>
</html>